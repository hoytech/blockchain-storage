<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Decentralized Storage Systems</title>

    <meta name="author" content="Doug Hoyte">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? '../reveal.js/css/print/pdf.css' : '../reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="../reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->

    <style>
      .reveal .slides h1, .reveal .slides h2, .reveal .slides h3 {
        text-transform: none;
      }

      .two-column {
        display: flex;
        flex-wrap: wrap;
      }

      .two-column em {
        margin: 20px;
      }

      .reveal .big-and-bold {
        font-weight: bold;
        font-size: 135%;
      }

      .reveal .shrunk-a-bit {
        font-size: 90%;
      }

      .reveal .shrunk-a-bit pre {
        width: 100%;
      }

      .reveal pre {
        width: 100%;
      }

      .reveal .highlight {
        color: yellow;
        font-weight: bold;
      }

      .reveal .highlightRed {
        color: red;
        font-weight: bold;
      }

      .reveal .highlightGreen {
        color: green;
        font-weight: bold;
      }

      .left {
        left:-8.33%;
        text-align: left;
        float: left;
        width:50%;
        z-index:-10;
      }

      .right {
        left:31.25%;
        top: 75px;
        text-align: left;
        float: right;
        z-index:-10;
        width:50%;
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

<!------------------------------------------------------->



<section data-markdown><script type="text/template">

## Decentralized Storage Systems

### Lesson 2: Merkle Trees

*Doug Hoyte, May 2019*

[https://is.gd/blockchainstorage](https://is.gd/blockchainstorage)

</script></section>



<section data-markdown><script type="text/template">

## Lesson Topics

* Proofs and witnesses
* Merkle trees
* Applications of merkle trees

</script></section>



<section data-markdown><script type="text/template">

## Storing hashes on-chain

* In some smart contract protocols, a user can commit to a certain value for a file, data-base, etc
* Because it is expensive to store data on-chain, it is common to hash this value and store the hash on-chain
  * Uploading the whole file might be impractical or impossible (may exceed gas block limit)

</script></section>




<section data-markdown><script type="text/template">

## Validating on-chain hashes

* In order for other protocol participants to access this file, they must download it by some off-chain method
  * Bittorrent, usenet, freenet, IPFS, secure scuttlebutt, centralized hosting, whatever
* The participant does **not** need to trust this off-chain source because they will verify the file against the on-chain hash
  * It is *content addressed*

</script></section>



<section data-markdown><script type="text/template">

## Bringing it back on-chain

* But what if a smart contract needs to access the file?
* If it had the file, the smart contract could hash the file and compare the hash. But it doesn't, and here we have the same problem as before:
  * It's too expensive/impossible to upload the file to the chain

</script></section>






<section data-markdown><script type="text/template">

## Password storage

* You should never store your users' passwords in plain-text
  * If your database is hacked then they will be exposed
  * This is bad because many users use the same password on multiple sites
* Instead you should store the output of a password hashing function
  * "Key derivation function"

</script></section>



<section data-markdown><script type="text/template">

## Password hashing functions

* Like regular hash functions, except:
  * Designed to be very slow to compute, so it takes a long time to crack
  * Supports salts
    * A non-secret random value included in the hash to prevent cracking multiple passwords at once

</script></section>



<section data-markdown><script type="text/template">

## Password database

Example unix password DB:

<pre class="hljs js" style="font-size: 45%">
alice:$2y$10$weUPjZkUXH6gsPt14UcR/uxCoHRVYf4oEe1CdAZTnHq8eM3SzbXsW
bob:$2y$10$DwIX.8e3sNlh8sMMJzS5P./j0BNtGwejh/dxvTH4TDjmBzoEOpfd.
carol:$2y$10$xK/m/d4vGlGLylOnQGb/kO4g16aC4S0VrsHOxVcG5zHHO3GQj/vwG
</pre>

* The DB doesn't store the plain-text passwords
* But if you have the DB you can verify somebody knows a password by hashing what they provide and comparing to what's in the DB
  * The password they provide is a **proof** they know the password

</script></section>





<section>

<p data-markdown>
## git
</p>

<div class="left">
    <img src="git1.svg" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* git stores a tree of *commits*
* Each commit is hashed and the hash is its id
* Each commit references its parents by their hashes
</p></div>

</section>



<section>

<div class="left">
    <img src="git2.svg" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* Suppose somebody knows the root node hash *`f910ba..`* and nothing else
* Let's say we want to prove to them that the "bugfix!!" commit exists in the tree
</p></div>

</section>




<section>

<div class="left">
    <img src="git3.svg" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* You send them the highlighted commits and they can re-compute the hash themselves to verify
* The purple is the node you are proving exists
* The red nodes are called "witnesses"
</p></div>

</section>




<section>

<div class="left">
    <img src="git3.svg" style="float: left; border:0px; background-color: white" />
</div>

<div class="right" style="font-size: 90%"><p data-markdown>
1. Hash the bugfix node and verify the "fix tests" witness node includes this hash
1. Hash the "fix tests" witness and verify the "merge commit" witness includes this hash
1. Hash the "merge commit" witness and verify the trusted hash matches this hash
</p></div>

</section>



<section>

<div class="left">
    <img src="git3.svg" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* Note that the verifier never needed any of the grey nodes to verify the proof
* If a secure hash function is used, there is no way to modify the "bugfix" commit and use it to make a valid proof
</p></div>

</section>






<section data-markdown><script type="text/template">

## 15 minute break

</script></section>



<section data-markdown><script type="text/template">

## Review: Trees

<img src="trees.svg" style="background-color: white;" />

</script></section>



<section data-markdown><script type="text/template">

## Merkle trees

* A merkle tree is a tree where each node references its lower nodes by their hashes
  * Often simply called a *hash tree*
* If somebody knows the root node hash, we can prove that any node exists by providing a **proof**
  * The proof may include some nodes that the prover isn't interested in but are needed to verify the proof: **witnesses**

</script></section>



<section data-markdown><script type="text/template">

## History of Merkle trees

* Invented by Ralph Merkle in late 70s
* Was first used to to implement hash-based signatures
  * See the [Signatures Made Simple](https://hoytech.github.io/blockchain-security/lesson1/index.html#/27) slide from our security course
  * By using Merkle trees, we can make key-pairs that can sign many messages
  * Modern hash-based signatures still use merkle trees, ie XMSS: eXtended Merkle Signature Scheme (RFC 8391)

</script></section>



<section data-markdown><script type="text/template">

## Why trees? Exponential growth

<img src="exponential.svg" style="background-color: white;" />

</script></section>



<section data-markdown><script type="text/template">

## Proof size

* Because of exponential growth, the number of nodes in our tree grows much faster than the number of levels
  * Each leaf node is a data item
  * Each level increases our proof size by 1 hash (we need a witness at that level)
* The number of witnesses required grows according to the *logarithm* of the data items
  * Proofs can be small, even for huge numbers of nodes

</script></section>








<section>

<p data-markdown>
## Verifiable data-base
</p>

<div class="left">
    <img width="100%" src="merkle1.svg" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* A merkle tree is a way of structuring a data-base in a way it can be verified with proofs
* Here is a DB with 8 elements in it
* 3 bit paths required, because:
  * log2(8) = 3
</p></div>

</section>



<section data-markdown><script type="text/template">
## Example proof (1/7)
<img src="merkle2.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example proof (2/7)
<img src="merkle3.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example proof (3/7)
<img src="merkle4.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example proof (4/7)
<img src="merkle5.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example proof (5/7)
<img src="merkle6.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example proof (6/7)
<img src="merkle7.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example proof (7/7)
<img src="merkle8.svg" style="background-color: white;" />
</script></section>




<section data-markdown><script type="text/template">
## Example validation (1/6)
<img src="validation1.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example validation (2/6)
<img src="validation2.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example validation (3/6)
<img src="validation3.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example validation (4/6)
<img src="validation4.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example validation (5/6)
<img src="validation5.svg" style="background-color: white;" />
</script></section>

<section data-markdown><script type="text/template">
## Example validation (6/6)
<img src="validation6.svg" style="background-color: white;" />
</script></section>




<section>

<p data-markdown>
## Odd number of items
</p>

<div class="left">
    <img width="100%" src="merkle-odd.svg" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* What do you do if you have an odd number of items on a layer?
</p></div>

</section>




<section>

<p data-markdown>
## Bitcoin bug CVE-2012-2459
</p>

<div class="left">
    <img width="100%" src="merkle-odd2.svg" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* Bitcoin protocol unconventionally duplicates last item
* This was a security bug because there are 2 possible DBs with same root:
* [0,1,2,3,4,5,6]
* [0,1,2,3,4,5,6,6]
</p></div>

</section>



<section>

<p data-markdown>
## Odd number of items, fixed
</p>

<div class="left">
    <img width="100%" src="merkle-odd3.svg" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* Better approach is to just move the odd node up a level
* In this case the proof for `6` would use the path `3 (11)` and only provide 2 witnesses
</p></div>

</section>




<section data-markdown><script type="text/template">

## Omitted path optimization

* In EOS there is a minor optimization where the prover doesn't need to provide the path along with a proof
* Each witness hash is truncated by 1 bit, and replaced with a bit that indicates "left" or "right"
  * Left:
<pre style="font-size: 75%">
<span class="highlight">0</span>10011001001110101100110011010011110011...
</pre>
  * Right:
<pre style="font-size: 75%">
<span class="highlight">1</span>11110110111100101000001110001101010100...
</pre>


</script></section>





<section data-markdown><script type="text/template">

## 15 minute break

</script></section>





<section data-markdown><script type="text/template">

## Attack: Reinterpret intermediate nodes as data element

<img src="merkle-attack.svg" style="background-color: white;" />

</script></section>



<section data-markdown><script type="text/template">

## Defense

* This attack is usually quite impractical, since the fake data element is the output of a hash function
* It can be prevented by hashing nodes differently from leafs
  * For example, prepend a byte:
    * H<sub>node</sub>(x) = H("\x00" + x)
    * H<sub>leaf</sub>(x) = H("\x01" + x)
  * Or use "keyed" hash functions (like BLAKE2) with different keys for node/leaf
  * Special tree-hashing schemes like Sakura

</script></section>




<section data-markdown><script type="text/template">

## Merkle Mountain Ranges

<img src="mmr.svg" style="background-color: white;" />

* If you don't have a power-of-two number of leaf nodes, an alternative is to have multiple roots
  * Roots are called "peaks", as in mountain peaks

</script></section>









<section data-markdown><script type="text/template">

## Simplified Payment Verification

* In Bitcoin it is possible to verify a transaction has been included in the blockchain without downloading all the blocks
* Only need the block headers of the longest chain
  * Keep asking nodes until you are sure you have longest chain
  * Get somebody who has the full chain to generate you a merkle proof
    * Electrum servers can do this

</script></section>



<section data-markdown><script type="text/template">

## Simplified Payment Verification

<img src="spv.svg" style="background-color: white;" />

</script></section>




<section>

<p data-markdown>
## Certificate transparency
</p>

<div class="left">
    <img width="100%" src="certtrans.png" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* Project that tries to keep SSL Certificate Authorities honest
* So they can't sign SSL certificates for spy agencies without getting caught
</p></div>

</section>




<section>

<p data-markdown>
## Merkle Patricia Trie
</p>

<div class="left">
    <img width="100%" src="trie.png" style="float: left; border:0px; background-color: white" />
</div>

<div class="right"><p data-markdown>
* Merkle Patricia Trie is a way to efficiently handle *sparse* paths, like the output of hash functions
* First implemented in Ripple, popularised by Ethereum
</p></div>

</section>




<section data-markdown><script type="text/template">

## Air-drops

* Some token creators want to give their tokens an initial distribution by giving them away
* Usually to every address who holds ETH at a certain block height
* This is why you may see unknown (usually worthless) tokens appear in your wallet sometimes

</script></section>




<section data-markdown><script type="text/template">

## Air-drops: Impossible way

* When creating the token contract, pass the list of addresses and their initial token balances in to the constructor
* Won't work because there could be millions of addresses
  * Can't fit that much data in a block
    * Exceeds block gas limit

</script></section>



<section data-markdown><script type="text/template">

## Air-drops: Inefficient way

* After creating the token contract, send transactions transferring tokens to each address
* Requires spamming the network with many transactions
  * Costs lots of ETH in gas
  * Most recipients don't even care about their tokens!

</script></section>



<section data-markdown><script type="text/template">

## Air-drops: Better way

* Use a merkle tree to commit to the initial balances
* Anybody can submit a proof and claim their tokens
  * The contract creator doesn't pay any gas for the distribution
  * Only people who care about their tokens need to pay gas

</script></section>



<section data-markdown><script type="text/template">

## Air-drops: Better way

* Use a merkle tree to commit to the initial balances
* Anybody can submit a proof and claim their tokens
  * The contract creator doesn't pay any gas for the distribution
  * Only people who care about their tokens need to pay gas

</script></section>




<section data-markdown><script type="text/template">

## Lab 2: Voting

[voting.html](voting.html)

</script></section>



<section data-markdown><script type="text/template">

## End of lesson

</script></section>



<!------------------------------------------------------->


      </div>

    </div>

    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'none', // none/fade/slide/convex/concave/zoom

	math: {
          mathjax: '../lib/MathJax/MathJax.js',
          config: 'TeX-AMS_SVG-full',
	},

        // Optional reveal.js plugins
        dependencies: [
          { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../reveal.js/plugin/math/math.js', async: true },
        ]
      });

    </script>

  </body>
</html>
